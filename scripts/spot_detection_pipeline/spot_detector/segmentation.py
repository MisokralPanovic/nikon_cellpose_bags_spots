import numpy as np
import cv2
import torch
from cellpose import models
from skimage.segmentation import clear_border



def cellpose_bag(
    image: np.ndarray, 
    model_path: str, 
    use_gpu: bool = True
    ) -> np.ndarray:
    """Run BAG-pretrained Cellpose-SAM.

    Args:
        image (np.ndarray): Input 2D BAG image for segmentation.
        model_path (str): Path to pretrained model.
        use_gpu (bool, optional): Whether to use GPU acceleration. Defaults to True.

    Raises:
        ValueError: _description_

    Returns:
        np.ndarray: Segmentation masks.
    """    
    model = models.CellposeModel(
        gpu = use_gpu,
        pretrained_model = model_path
    )
    
    masks, flows, styles = model.eval(image)
    del flows, styles
    
    if use_gpu:
        torch.cuda.empty_cache()
    
    return masks

def downsample(
    image: np.ndarray, 
    scale_factor: float
    ) -> np.ndarray:
    """Downsample an image by a given scale factor.

    Args:
        image (np.ndarray): Input image to downsample.
        scale_factor (float): Downsample factor, must be between 0.0 and 1.0.

    Raises:
        ValueError: If scale_factor is outside valid range.

    Returns:
        np.ndarray: Downsampeled original image.
    """
    if not 0.0 < scale_factor <= 1.0:
        raise ValueError("scale_factor must be between 0.0 and 1.0.")

    original_height, original_width = image.shape[:2]
    new_width = int(original_width * scale_factor)
    new_height = int(original_height * scale_factor)
    new_dimensions = (new_width, new_height)

    downscaled_image = cv2.resize(
        image,
        new_dimensions,
        interpolation=cv2.INTER_AREA
    )

    return downscaled_image

def upsample_mask(
    mask: np.ndarray, 
    original_shape: tuple
    ) -> np.ndarray:
    """Upsample segmentation masks to original image shape.

    Args:
        mask (np.ndarray): Masks generated by Cellpose run on downsampled images.
        original_shape (tuple): Dimentions of original image.

    Returns:
        np.ndarray: Segemntation masks upscaled to original dimentions.
    """
    original_height, original_width = original_shape[:2]
    target_dimensions = (original_width, original_height)

    upscaled_mask = cv2.resize(
        mask,
        target_dimensions,
        interpolation=cv2.INTER_NEAREST
    )

    return upscaled_mask

def memory_efficient_segmentation(
    image: np.ndarray, 
    model_path: str, 
    scale_factor: float, 
    use_gpu: bool = True,
    buffer_size: int = 10
    ) -> np.ndarray:
    """Run memory efficient Cellpose-SAM BAG segmentation.

    Args:
        image (np.ndarray): Input 2D BAG image for segmentation.
        model_path (str): Path to pretrained model.
        scale_factor (float): Downsample factor, must be between 0.0 and 1.0.
        use_gpu (bool, optional): Whether to use GPU acceleration. Defaults to True.
        buffer_size (int, optional): _description_. Defaults to 10.

    Returns:
        np.ndarray: Segmentation masks not touching borders (complete objects).
    """
    downsampled = downsample(image, scale_factor)
    
    masks = cellpose_bag(downsampled, model_path, use_gpu)
    del downsampled
    
    upsampled_masks = upsample_mask(masks, image.shape)
    del masks
    
    filtered_masks = clear_border(upsampled_masks, buffer_size=buffer_size)
    del upsampled_masks
    
    return filtered_masks